// TCG TPM2 Structures interface code
// Autogenerated with gen-tpm2-cmd-interface version 0.1.0

#![forbid(unsafe_code)]
#![allow(dead_code)]

use core::convert;
use core::mem;
use core::ops;
use kinded::Kinded;
use std::cmp;

#[derive(Clone, Copy, Debug)]
pub enum TpmErr {
    Rc(u32),
    InternalErr,
}

#[derive(Clone, Debug)]
pub enum TpmBuffer<'a> {
    Borrowed(&'a [u8]),
    Owned(Vec<u8>),
}

impl<'a> TpmBuffer<'a> {
    pub fn into_owned(self) -> Result<TpmBuffer<'static>, TpmErr> {
        let o = match self {
            Self::Borrowed(b) => b.to_vec(),
            Self::Owned(o) => o,
        };
        Ok(TpmBuffer::<'static>::Owned(o))
    }
}

impl<'a> ops::Deref for TpmBuffer<'a> {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        match self {
            Self::Borrowed(b) => b,
            Self::Owned(o) => o,
        }
    }
}

impl<'a> convert::From<&'a [u8]> for TpmBuffer<'a> {
    fn from(value: &'a [u8]) -> Self {
        Self::Borrowed(value)
    }
}

impl<'a> PartialEq for TpmBuffer<'a> {
    fn eq(&self, other: &Self) -> bool {
        <Self as ops::Deref>::deref(self) == <Self as ops::Deref>::deref(other)
    }
}
#[derive(Clone, Debug)]
pub struct TpmLimits {
    pub hash_count: u32,
    pub implementation_pcr: u32,
    pub max_nv_buffer_size: u16,
    pub max_rsa_key_bytes: u16,
    pub platform_pcr: u32,
}

impl Default for TpmLimits {
    fn default() -> Self {
        TpmLimits {
            hash_count: 16,
            implementation_pcr: 32,
            max_nv_buffer_size: 2048,
            max_rsa_key_bytes: 4096,
            platform_pcr: 0,
        }
    }
}

impl TpmLimits {
    fn max_ecc_key_bytes(&self) -> Result<u16, ()> {
        let mut max_ecc_key_bits: u16 = 0;
        {
            max_ecc_key_bits = max_ecc_key_bits.max(192);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(224);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(384);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(521);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(638);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(384);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(512);
        }
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }

        Ok(max_ecc_key_bits.checked_add(7).ok_or(())? / 8)
    }

    fn pcr_select_max(&self) -> Result<u8, ()> {
        let pcr_select_max =
            u8::try_from(self.implementation_pcr.checked_add(7).ok_or(())? / 8).or(Err(()))?;
        Ok(pcr_select_max)
    }

    fn pcr_select_min(&self) -> Result<u8, ()> {
        let pcr_select_min =
            u8::try_from(self.platform_pcr.checked_add(7).ok_or(())? / 8).or(Err(()))?;
        Ok(pcr_select_min)
    }
}

#[allow(unused)]
fn split_slice_at<T>(s: &[T], mid: usize) -> Result<(&[T], &[T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
    }
    Ok(s.split_at(mid))
}

#[allow(unused)]
fn split_slice_at_mut<T>(s: &mut [T], mid: usize) -> Result<(&mut [T], &mut [T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::InternalErr);
    }
    Ok(s.split_at_mut(mid))
}

#[allow(unused)]
pub fn unmarshal_u8(buf: &[u8]) -> Result<(&[u8], u8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u8>())?;
    let consumed =
        <&[u8; mem::size_of::<u8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i8(buf: &[u8]) -> Result<(&[u8], i8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i8>())?;
    let consumed =
        <&[u8; mem::size_of::<i8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u16(buf: &[u8]) -> Result<(&[u8], u16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u16>())?;
    let consumed =
        <&[u8; mem::size_of::<u16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i16(buf: &[u8]) -> Result<(&[u8], i16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i16>())?;
    let consumed =
        <&[u8; mem::size_of::<i16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u32(buf: &[u8]) -> Result<(&[u8], u32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u32>())?;
    let consumed =
        <&[u8; mem::size_of::<u32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i32(buf: &[u8]) -> Result<(&[u8], i32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i32>())?;
    let consumed =
        <&[u8; mem::size_of::<i32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u64(buf: &[u8]) -> Result<(&[u8], u64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u64>())?;
    let consumed =
        <&[u8; mem::size_of::<u64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i64(buf: &[u8]) -> Result<(&[u8], i64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i64>())?;
    let consumed =
        <&[u8; mem::size_of::<i64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn marshal_u8(buf: &mut [u8], value: u8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u8>())?;
    let produced =
        <&mut [u8; mem::size_of::<u8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i8(buf: &mut [u8], value: i8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i8>())?;
    let produced =
        <&mut [u8; mem::size_of::<i8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u16(buf: &mut [u8], value: u16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u16>())?;
    let produced =
        <&mut [u8; mem::size_of::<u16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i16(buf: &mut [u8], value: i16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i16>())?;
    let produced =
        <&mut [u8; mem::size_of::<i16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u32(buf: &mut [u8], value: u32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u32>())?;
    let produced =
        <&mut [u8; mem::size_of::<u32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i32(buf: &mut [u8], value: i32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i32>())?;
    let produced =
        <&mut [u8; mem::size_of::<i32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u64(buf: &mut [u8], value: u64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u64>())?;
    let produced =
        <&mut [u8; mem::size_of::<u64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i64(buf: &mut [u8], value: i64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i64>())?;
    let produced =
        <&mut [u8; mem::size_of::<i64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
fn marshal_bytes<'a>(buf: &'a mut [u8], src: &[u8]) -> Result<&'a mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, src.len())?;
    produced.copy_from_slice(src);
    Ok(buf)
}

// TCG Algorithm Registry (rev 01.32), page 11, table 3, TPM_ALG_ID constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmAlgId {
    Error = 0x0u16,
    Rsa = 0x1u16,
    Tdes = 0x3u16,
    Sha1 = 0x4u16,
    Hmac = 0x5u16,
    Aes = 0x6u16,
    Mgf1 = 0x7u16,
    Keyedhash = 0x8u16,
    Xor = 0xau16,
    Sha256 = 0xbu16,
    Sha384 = 0xcu16,
    Sha512 = 0xdu16,
    Null = 0x10u16,
    Sm3_256 = 0x12u16,
    Sm4 = 0x13u16,
    Rsassa = 0x14u16,
    Rsaes = 0x15u16,
    Rsapss = 0x16u16,
    Oaep = 0x17u16,
    Ecdsa = 0x18u16,
    Ecdh = 0x19u16,
    Ecdaa = 0x1au16,
    Sm2 = 0x1bu16,
    Ecschnorr = 0x1cu16,
    Ecmqv = 0x1du16,
    Kdf1Sp800_56a = 0x20u16,
    Kdf2 = 0x21u16,
    Kdf1Sp800_108 = 0x22u16,
    Ecc = 0x23u16,
    Symcipher = 0x25u16,
    Camellia = 0x26u16,
    Sha3_256 = 0x27u16,
    Sha3_384 = 0x28u16,
    Sha3_512 = 0x29u16,
    Cmac = 0x3fu16,
    Ctr = 0x40u16,
    Ofb = 0x41u16,
    Cbc = 0x42u16,
    Cfb = 0x43u16,
    Ecb = 0x44u16,
    Ccm = 0x50u16,
    Gcm = 0x51u16,
    Kw = 0x52u16,
    Kwp = 0x53u16,
    Eax = 0x54u16,
    Eddsa = 0x60u16,
}

impl TpmAlgId {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmAlgId {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Error as u16 => Self::Error,
            value if value == Self::Rsa as u16 => Self::Rsa,
            value if value == Self::Tdes as u16 => Self::Tdes,
            value if value == Self::Sha1 as u16 => Self::Sha1,
            value if value == Self::Hmac as u16 => Self::Hmac,
            value if value == Self::Aes as u16 => Self::Aes,
            value if value == Self::Mgf1 as u16 => Self::Mgf1,
            value if value == Self::Keyedhash as u16 => Self::Keyedhash,
            value if value == Self::Xor as u16 => Self::Xor,
            value if value == Self::Sha256 as u16 => Self::Sha256,
            value if value == Self::Sha384 as u16 => Self::Sha384,
            value if value == Self::Sha512 as u16 => Self::Sha512,
            value if value == Self::Null as u16 => Self::Null,
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            value if value == Self::Sm4 as u16 => Self::Sm4,
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            value if value == Self::Oaep as u16 => Self::Oaep,
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            value if value == Self::Sm2 as u16 => Self::Sm2,
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            value if value == Self::Kdf1Sp800_56a as u16 => Self::Kdf1Sp800_56a,
            value if value == Self::Kdf2 as u16 => Self::Kdf2,
            value if value == Self::Kdf1Sp800_108 as u16 => Self::Kdf1Sp800_108,
            value if value == Self::Ecc as u16 => Self::Ecc,
            value if value == Self::Symcipher as u16 => Self::Symcipher,
            value if value == Self::Camellia as u16 => Self::Camellia,
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            value if value == Self::Cmac as u16 => Self::Cmac,
            value if value == Self::Ctr as u16 => Self::Ctr,
            value if value == Self::Ofb as u16 => Self::Ofb,
            value if value == Self::Cbc as u16 => Self::Cbc,
            value if value == Self::Cfb as u16 => Self::Cfb,
            value if value == Self::Ecb as u16 => Self::Ecb,
            value if value == Self::Ccm as u16 => Self::Ccm,
            value if value == Self::Gcm as u16 => Self::Gcm,
            value if value == Self::Kw as u16 => Self::Kw,
            value if value == Self::Kwp as u16 => Self::Kwp,
            value if value == Self::Eax as u16 => Self::Eax,
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok(result)
    }
}

// TCG Algorithm Registry (rev 01.32), page 15, table 4, TPM_ECC_CURVE constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
enum TpmEccCurve {
    NistP192 = 0x1u16,
    NistP224 = 0x2u16,
    NistP256 = 0x3u16,
    NistP384 = 0x4u16,
    NistP521 = 0x5u16,
    BnP256 = 0x10u16,
    BnP638 = 0x11u16,
    Sm2P256 = 0x20u16,
    BpP256R1 = 0x30u16,
    BpP384R1 = 0x31u16,
    BpP512R1 = 0x32u16,
    Curve25519 = 0x40u16,
}

// TCG TPM2 Library (rev 01.59), Part 2, page 41, table 7, TPM_GENERATED constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmGenerated {
    Value = 0xff544347u32,
}

impl TpmGenerated {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmGenerated {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Value as u32 => Self::Value,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 54, table 16, TPM_RC constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct TpmRc {}

impl TpmRc {
    const FMT1: u32 = 0x80u32;
    const HASH: u32 = Self::FMT1 + 0x3u32;
    const VALUE: u32 = Self::FMT1 + 0x4u32;
    const MODE: u32 = Self::FMT1 + 0x9u32;
    const TYPE: u32 = Self::FMT1 + 0xau32;
    const KDF: u32 = Self::FMT1 + 0xcu32;
    const SCHEME: u32 = Self::FMT1 + 0x12u32;
    const SIZE: u32 = Self::FMT1 + 0x15u32;
    const SYMMETRIC: u32 = Self::FMT1 + 0x16u32;
    const INSUFFICIENT: u32 = Self::FMT1 + 0x1au32;
    const RESERVED_BITS: u32 = Self::FMT1 + 0x21u32;
    const CURVE: u32 = Self::FMT1 + 0x26u32;
    const WARN: u32 = 0x900u32;
    const MEMORY: u32 = Self::WARN + 0x4u32;
}

// TCG TPM2 Library (rev 01.59), Part 2, page 61, table 19, TPM_ST constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
enum TpmSt {
    AttestNv = 0x8014u16,
    AttestCommandAudit = 0x8015u16,
    AttestSessionAudit = 0x8016u16,
    AttestCertify = 0x8017u16,
    AttestQuote = 0x8018u16,
    AttestTime = 0x8019u16,
    AttestCreation = 0x801au16,
    AttestNvDigest = 0x801cu16,
}

// TCG TPM2 Library (rev 01.59), Part 2, page 80, table 31, TPMA_OBJECT bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaObject {
    value: u32,
}

impl TpmaObject {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const FIXED_TPM_MASK: u32 = 1u32 << 1u32;

    pub fn get_fixed_tpm(&self) -> bool {
        self.value & Self::FIXED_TPM_MASK != 0
    }

    pub fn set_fixed_tpm(&mut self, value: bool) {
        if value {
            self.value |= Self::FIXED_TPM_MASK;
        } else {
            self.value &= !Self::FIXED_TPM_MASK;
        }
    }

    const ST_CLEAR_MASK: u32 = 1u32 << 2u32;

    pub fn get_st_clear(&self) -> bool {
        self.value & Self::ST_CLEAR_MASK != 0
    }

    pub fn set_st_clear(&mut self, value: bool) {
        if value {
            self.value |= Self::ST_CLEAR_MASK;
        } else {
            self.value &= !Self::ST_CLEAR_MASK;
        }
    }

    const FIXED_PARENT_MASK: u32 = 1u32 << 4u32;

    pub fn get_fixed_parent(&self) -> bool {
        self.value & Self::FIXED_PARENT_MASK != 0
    }

    pub fn set_fixed_parent(&mut self, value: bool) {
        if value {
            self.value |= Self::FIXED_PARENT_MASK;
        } else {
            self.value &= !Self::FIXED_PARENT_MASK;
        }
    }

    const SENSITIVE_DATA_ORIGIN_MASK: u32 = 1u32 << 5u32;

    pub fn get_sensitive_data_origin(&self) -> bool {
        self.value & Self::SENSITIVE_DATA_ORIGIN_MASK != 0
    }

    pub fn set_sensitive_data_origin(&mut self, value: bool) {
        if value {
            self.value |= Self::SENSITIVE_DATA_ORIGIN_MASK;
        } else {
            self.value &= !Self::SENSITIVE_DATA_ORIGIN_MASK;
        }
    }

    const USER_WITH_AUTH_MASK: u32 = 1u32 << 6u32;

    pub fn get_user_with_auth(&self) -> bool {
        self.value & Self::USER_WITH_AUTH_MASK != 0
    }

    pub fn set_user_with_auth(&mut self, value: bool) {
        if value {
            self.value |= Self::USER_WITH_AUTH_MASK;
        } else {
            self.value &= !Self::USER_WITH_AUTH_MASK;
        }
    }

    const ADMIN_WITH_POLICY_MASK: u32 = 1u32 << 7u32;

    pub fn get_admin_with_policy(&self) -> bool {
        self.value & Self::ADMIN_WITH_POLICY_MASK != 0
    }

    pub fn set_admin_with_policy(&mut self, value: bool) {
        if value {
            self.value |= Self::ADMIN_WITH_POLICY_MASK;
        } else {
            self.value &= !Self::ADMIN_WITH_POLICY_MASK;
        }
    }

    const NO_DA_MASK: u32 = 1u32 << 10u32;

    pub fn get_no_da(&self) -> bool {
        self.value & Self::NO_DA_MASK != 0
    }

    pub fn set_no_da(&mut self, value: bool) {
        if value {
            self.value |= Self::NO_DA_MASK;
        } else {
            self.value &= !Self::NO_DA_MASK;
        }
    }

    const ENCRYPTED_DUPLICATION_MASK: u32 = 1u32 << 11u32;

    pub fn get_encrypted_duplication(&self) -> bool {
        self.value & Self::ENCRYPTED_DUPLICATION_MASK != 0
    }

    pub fn set_encrypted_duplication(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCRYPTED_DUPLICATION_MASK;
        } else {
            self.value &= !Self::ENCRYPTED_DUPLICATION_MASK;
        }
    }

    const RESTRICTED_MASK: u32 = 1u32 << 16u32;

    pub fn get_restricted(&self) -> bool {
        self.value & Self::RESTRICTED_MASK != 0
    }

    pub fn set_restricted(&mut self, value: bool) {
        if value {
            self.value |= Self::RESTRICTED_MASK;
        } else {
            self.value &= !Self::RESTRICTED_MASK;
        }
    }

    const DECRYPT_MASK: u32 = 1u32 << 17u32;

    pub fn get_decrypt(&self) -> bool {
        self.value & Self::DECRYPT_MASK != 0
    }

    pub fn set_decrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::DECRYPT_MASK;
        } else {
            self.value &= !Self::DECRYPT_MASK;
        }
    }

    const SIGN_ENCRYPT_MASK: u32 = 1u32 << 18u32;

    pub fn get_sign_encrypt(&self) -> bool {
        self.value & Self::SIGN_ENCRYPT_MASK != 0
    }

    pub fn set_sign_encrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::SIGN_ENCRYPT_MASK;
        } else {
            self.value &= !Self::SIGN_ENCRYPT_MASK;
        }
    }

    const X509_SIGN_MASK: u32 = 1u32 << 19u32;

    pub fn get_x509_sign(&self) -> bool {
        self.value & Self::X509_SIGN_MASK != 0
    }

    pub fn set_x509_sign(&mut self, value: bool) {
        if value {
            self.value |= Self::X509_SIGN_MASK;
        } else {
            self.value &= !Self::X509_SIGN_MASK;
        }
    }

    const RESERVED_MASK0: u32 = 1u32 << 0u32;
    const RESERVED_MASK1: u32 = 1u32 << 3u32;
    const RESERVED_MASK2: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 9u32 + 8u32) << 8u32;
    const RESERVED_MASK3: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 15u32 + 12u32) << 12u32;
    const RESERVED_MASK4: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 20u32) << 20u32;
    const RESERVED_MASK: u32 = Self::RESERVED_MASK0
        | Self::RESERVED_MASK1
        | Self::RESERVED_MASK2
        | Self::RESERVED_MASK3
        | Self::RESERVED_MASK4;

    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaObject {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 98, table 40, TPMI_YES_NO type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiYesNo {
    pub value: u8,
}

impl TpmiYesNo {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;

        if value == 0u8 {
            return Ok((buf, Self { value }));
        }

        if value == 1u8 {
            return Ok((buf, Self { value }));
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 107, table 65, TPMI_ALG_HASH type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgHash {
    Sha1 = TpmAlgId::Sha1 as u16,
    Sha256 = TpmAlgId::Sha256 as u16,
    Sha384 = TpmAlgId::Sha384 as u16,
    Sha512 = TpmAlgId::Sha512 as u16,
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
}

impl TpmiAlgHash {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgHash {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Sha1 as u16 => Self::Sha1,
            value if value == Self::Sha256 as u16 => Self::Sha256,
            value if value == Self::Sha384 as u16 => Self::Sha384,
            value if value == Self::Sha512 as u16 => Self::Sha512,
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 108, table 68, TPMI_ALG_SYM_OBJECT type (without conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgSymObject {}

impl TpmiAlgSymObject {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 108, table 68, TPMI_ALG_SYM_OBJECT type (with conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgSymObjectWCV {}

impl TpmiAlgSymObjectWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 108, table 69, TPMI_ALG_SYM_MODE type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSymModeWCV {
    Ctr = TpmAlgId::Ctr as u16,
    Ofb = TpmAlgId::Ofb as u16,
    Cbc = TpmAlgId::Cbc as u16,
    Cfb = TpmAlgId::Cfb as u16,
    Ecb = TpmAlgId::Ecb as u16,
    Cmac = TpmAlgId::Cmac as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgSymModeWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymModeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Ctr as u16 => Self::Ctr,
            value if value == Self::Ofb as u16 => Self::Ofb,
            value if value == Self::Cbc as u16 => Self::Cbc,
            value if value == Self::Cfb as u16 => Self::Cfb,
            value if value == Self::Ecb as u16 => Self::Ecb,
            value if value == Self::Cmac as u16 => Self::Cmac,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 109, table 70, TPMI_ALG_KDF type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgKdfWCV {
    Mgf1 = TpmAlgId::Mgf1 as u16,
    Kdf1Sp800_56a = TpmAlgId::Kdf1Sp800_56a as u16,
    Kdf2 = TpmAlgId::Kdf2 as u16,
    Kdf1Sp800_108 = TpmAlgId::Kdf1Sp800_108 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgKdfWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgKdfWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Mgf1 as u16 => Self::Mgf1,
            value if value == Self::Kdf1Sp800_56a as u16 => Self::Kdf1Sp800_56a,
            value if value == Self::Kdf2 as u16 => Self::Kdf2,
            value if value == Self::Kdf1Sp800_108 as u16 => Self::Kdf1Sp800_108,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 109, table 71, TPMI_ALG_SIG_SCHEME type (without conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgSigScheme {}

impl TpmiAlgSigScheme {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 111, table 76, TPMS_EMPTY structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsEmpty {}

impl TpmsEmpty {
    const fn marshalled_size() -> u16 {
        tpms_empty_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        Ok((buf, Self {}))
    }
}

const fn tpms_empty_marshalled_size() -> u16 {
    let size: u16 = 0;
    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 111, table 78, TPMU_HA union
struct TpmuHa {}

impl TpmuHa {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        {
            let sha1_size = 20u16;
            if sha1_size > size {
                size = sha1_size;
            }
        }

        {
            let sha256_size = 32u16;
            if sha256_size > size {
                size = sha256_size;
            }
        }

        {
            let sha384_size = 48u16;
            if sha384_size > size {
                size = sha384_size;
            }
        }

        {
            let sha512_size = 64u16;
            if sha512_size > size {
                size = sha512_size;
            }
        }

        {
            let sm3_256_size = 32u16;
            if sm3_256_size > size {
                size = sm3_256_size;
            }
        }

        {
            let sha3_256_size = 32u16;
            if sha3_256_size > size {
                size = sha3_256_size;
            }
        }

        {
            let sha3_384_size = 48u16;
            if sha3_384_size > size {
                size = sha3_384_size;
            }
        }

        {
            let sha3_512_size = 64u16;
            if sha3_512_size > size {
                size = sha3_512_size;
            }
        }

        size
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 112, table 79, TPMT_HA structure (without conditional values)
#[derive(Debug, PartialEq)]
#[repr(C, u16)]
pub enum TpmtHa<'a> {
    Sha1(TpmBuffer<'a>) = TpmAlgId::Sha1 as u16,
    Sha256(TpmBuffer<'a>) = TpmAlgId::Sha256 as u16,
    Sha384(TpmBuffer<'a>) = TpmAlgId::Sha384 as u16,
    Sha512(TpmBuffer<'a>) = TpmAlgId::Sha512 as u16,
    Sm3_256(TpmBuffer<'a>) = TpmAlgId::Sm3_256 as u16,
    Sha3_256(TpmBuffer<'a>) = TpmAlgId::Sha3_256 as u16,
    Sha3_384(TpmBuffer<'a>) = TpmAlgId::Sha3_384 as u16,
    Sha3_512(TpmBuffer<'a>) = TpmAlgId::Sha3_512 as u16,
}

impl<'a> TpmtHa<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgHash::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Sha1(_) => {
                let digest_size = match usize::try_from(20u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sm3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha3_384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sha3_512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::Sha1(digest) => {
                let selector = TpmAlgId::Sha1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(20u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha256(digest) => {
                let selector = TpmAlgId::Sha256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha384(digest) => {
                let selector = TpmAlgId::Sha384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha512(digest) => {
                let selector = TpmAlgId::Sha512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sm3_256(digest) => {
                let selector = TpmAlgId::Sm3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha3_256(digest) => {
                let selector = TpmAlgId::Sha3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha3_384(digest) => {
                let selector = TpmAlgId::Sha3_384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
            Self::Sha3_512(digest) => {
                let selector = TpmAlgId::Sha3_512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    }
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_hash_alg {
            value if value == TpmAlgId::Sha1 as u16 => {
                let digest_size: u32 = 20u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha1(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha256(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha384(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha512(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sm3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sm3_256(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_256(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha3_384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_384(unmarshalled_digest))
            }
            value if value == TpmAlgId::Sha3_512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    }
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    }
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_512(unmarshalled_digest))
            }
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            }
        };

        Ok((buf, r))
    }
}

const fn tpmt_ha_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += TpmuHa::marshalled_max_size();

    size
}

impl<'a> convert::From<&TpmtHa<'a>> for TpmiAlgHash {
    fn from(value: &TpmtHa<'a>) -> Self {
        match value {
            TpmtHa::Sha1(_) => Self::Sha1,
            TpmtHa::Sha256(_) => Self::Sha256,
            TpmtHa::Sha384(_) => Self::Sha384,
            TpmtHa::Sha512(_) => Self::Sha512,
            TpmtHa::Sm3_256(_) => Self::Sm3_256,
            TpmtHa::Sha3_256(_) => Self::Sha3_256,
            TpmtHa::Sha3_384(_) => Self::Sha3_384,
            TpmtHa::Sha3_512(_) => Self::Sha3_512,
        }
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 113, table 80, TPM2B_DIGEST structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bDigest<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bDigest<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > TpmuHa::marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((
            buf,
            Self {
                buffer: unmarshalled_buffer,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 113, table 81, TPM2B_DATA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bData<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bData<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > tpmt_ha_marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((
            buf,
            Self {
                buffer: unmarshalled_buffer,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 114, table 87, TPM2B_MAX_NV_BUFFER structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bMaxNvBuffer<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bMaxNvBuffer<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_nv_buffer_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((
            buf,
            Self {
                buffer: unmarshalled_buffer,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 115, table 90, TPMU_NAME union
struct TpmuName {}

impl TpmuName {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        let digest_size = tpmt_ha_marshalled_max_size();
        if digest_size > size {
            size = digest_size;
        }

        let handle_size = mem::size_of::<u32>() as u16;
        if handle_size > size {
            size = handle_size;
        }

        size
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 116, table 91, TPM2B_NAME structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bName<'a> {
    pub name: TpmBuffer<'a>,
}

impl<'a> Tpm2bName<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let name_size = self.name.len();
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.name.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.name)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let name_size: u16 = unmarshalled_size;
        if name_size > TpmuName::marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let name_size = match usize::try_from(name_size) {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_name, buf) = match split_slice_at(buf, name_size) {
            Ok((unmarshalled_name, buf)) => (unmarshalled_name, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_name = TpmBuffer::from(unmarshalled_name);

        Ok((
            buf,
            Self {
                name: unmarshalled_name,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 117, table 93, TPMS_PCR_SELECTION structure
#[derive(Debug, PartialEq)]
pub struct TpmsPcrSelection<'a> {
    pub hash: TpmiAlgHash,
    pub pcr_select: TpmBuffer<'a>,
}

impl<'a> TpmsPcrSelection<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let sizeof_select_size = mem::size_of::<u8>();
        size = match size.checked_add(sizeof_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let pcr_select_size = self.pcr_select.len();
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let marshalled_sizeof_select = match u8::try_from(self.pcr_select.len()) {
            Ok(marshalled_sizeof_select) => marshalled_sizeof_select,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u8(buf, marshalled_sizeof_select)?;

        let buf = marshal_bytes(buf, &self.pcr_select)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_sizeof_select) = match unmarshal_u8(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };
        let v0 = match limits.pcr_select_min() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            }
        };
        if unmarshalled_sizeof_select < v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }

        let pcr_select_size: u8 = unmarshalled_sizeof_select;
        let v0 = match limits.pcr_select_max() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            }
        };
        if pcr_select_size > v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }
        let pcr_select_size = match usize::try_from(pcr_select_size) {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_pcr_select, buf) = match split_slice_at(buf, pcr_select_size) {
            Ok((unmarshalled_pcr_select, buf)) => (unmarshalled_pcr_select, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_pcr_select = TpmBuffer::from(unmarshalled_pcr_select);

        Ok((
            buf,
            Self {
                hash: unmarshalled_hash,
                pcr_select: unmarshalled_pcr_select,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 125, table 111, TPML_PCR_SELECTION structure
#[derive(Debug, PartialEq)]
pub struct TpmlPcrSelection<'a> {
    pub pcr_selections: Vec<TpmsPcrSelection<'a>>,
}

impl<'a> TpmlPcrSelection<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let mut pcr_selections_size: usize = 0;
        for element in self.pcr_selections.iter() {
            let pcr_selections_element_size = match element.marshalled_size() {
                Ok(pcr_selections_element_size) => pcr_selections_element_size,
                Err(_) => {
                    return Err(());
                }
            };
            pcr_selections_size = match pcr_selections_size.checked_add(pcr_selections_element_size)
            {
                Some(pcr_selections_size) => pcr_selections_size,
                None => {
                    return Err(());
                }
            };
        }
        size = match size.checked_add(pcr_selections_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.pcr_selections.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.pcr_selections.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let pcr_selections_len: u32 = unmarshalled_count;
        if pcr_selections_len > limits.hash_count {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let pcr_selections_len = match usize::try_from(pcr_selections_len) {
            Ok(pcr_selections_len) => pcr_selections_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let mut unmarshalled_pcr_selections: Vec<TpmsPcrSelection<'a>> = Vec::new();
        if unmarshalled_pcr_selections
            .try_reserve_exact(pcr_selections_len)
            .is_err()
        {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..pcr_selections_len {
            let (remaining, unmarshalled_element) =
                match TpmsPcrSelection::<'_>::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };
            unmarshalled_pcr_selections.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((
            buf,
            Self {
                pcr_selections: unmarshalled_pcr_selections,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 129, table 120, TPMS_CLOCK_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsClockInfo {
    pub clock: u64,
    pub reset_count: u32,
    pub restart_count: u32,
    pub safe: TpmiYesNo,
}

impl TpmsClockInfo {
    const fn marshalled_size() -> u16 {
        tpms_clock_info_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.clock)?;

        let buf = marshal_u32(buf, self.reset_count)?;

        let buf = marshal_u32(buf, self.restart_count)?;

        let buf = self.safe.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_clock) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_reset_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_restart_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_safe) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                clock: unmarshalled_clock,
                reset_count: unmarshalled_reset_count,
                restart_count: unmarshalled_restart_count,
                safe: unmarshalled_safe,
            },
        ))
    }
}

const fn tpms_clock_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 130, table 121, TPMS_TIME_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsTimeInfo {
    pub time: u64,
    pub clock_info: TpmsClockInfo,
}

impl TpmsTimeInfo {
    const fn marshalled_size() -> u16 {
        tpms_time_info_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.time)?;

        let buf = self.clock_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_time) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_clock_info) = match TpmsClockInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                time: unmarshalled_time,
                clock_info: unmarshalled_clock_info,
            },
        ))
    }
}

const fn tpms_time_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;
    size += tpms_clock_info_marshalled_size();

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 131, table 122, TPMS_TIME_ATTEST_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsTimeAttestInfo {
    pub time: TpmsTimeInfo,
    pub firmware_version: u64,
}

impl TpmsTimeAttestInfo {
    const fn marshalled_size() -> u16 {
        tpms_time_attest_info_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.time.marshal(buf)?;

        let buf = marshal_u64(buf, self.firmware_version)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_time) = match TpmsTimeInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_firmware_version) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                time: unmarshalled_time,
                firmware_version: unmarshalled_firmware_version,
            },
        ))
    }
}

const fn tpms_time_attest_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += tpms_time_info_marshalled_size();
    size += mem::size_of::<u64>() as u16;

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 131, table 123, TPMS_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCertifyInfo<'a> {
    pub name: Tpm2bName<'a>,
    pub qualified_name: Tpm2bName<'a>,
}

impl<'a> TpmsCertifyInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let qualified_name_size = match self.qualified_name.marshalled_size() {
            Ok(qualified_name_size) => qualified_name_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(qualified_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.name.marshal(buf)?;

        let buf = self.qualified_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_name) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_qualified_name) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                name: unmarshalled_name,
                qualified_name: unmarshalled_qualified_name,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 131, table 124, TPMS_QUOTE_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsQuoteInfo<'a> {
    pub pcr_select: TpmlPcrSelection<'a>,
    pub pcr_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsQuoteInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_select_size = match self.pcr_select.marshalled_size() {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let pcr_digest_size = match self.pcr_digest.marshalled_size() {
            Ok(pcr_digest_size) => pcr_digest_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(pcr_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_select.marshal(buf)?;

        let buf = self.pcr_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_select) =
            match TpmlPcrSelection::<'_>::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        let (buf, unmarshalled_pcr_digest) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                pcr_select: unmarshalled_pcr_select,
                pcr_digest: unmarshalled_pcr_digest,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 132, table 125, TPMS_COMMAND_AUDIT_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCommandAuditInfo<'a> {
    pub audit_counter: u64,
    pub digest_alg: TpmAlgId,
    pub audit_digest: Tpm2bDigest<'a>,
    pub command_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsCommandAuditInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let audit_counter_size = mem::size_of::<u64>();
        size = match size.checked_add(audit_counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let digest_alg_size = match usize::try_from(TpmAlgId::marshalled_size()) {
            Ok(digest_alg_size) => digest_alg_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(digest_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let audit_digest_size = match self.audit_digest.marshalled_size() {
            Ok(audit_digest_size) => audit_digest_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(audit_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let command_digest_size = match self.command_digest.marshalled_size() {
            Ok(command_digest_size) => command_digest_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(command_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.audit_counter)?;

        let buf = self.digest_alg.marshal(buf)?;

        let buf = self.audit_digest.marshal(buf)?;

        let buf = self.command_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_audit_counter) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_digest_alg) = match TpmAlgId::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_audit_digest) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_command_digest) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                audit_counter: unmarshalled_audit_counter,
                digest_alg: unmarshalled_digest_alg,
                audit_digest: unmarshalled_audit_digest,
                command_digest: unmarshalled_command_digest,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 132, table 126, TPMS_SESSION_AUDIT_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsSessionAuditInfo<'a> {
    pub exclusive_session: TpmiYesNo,
    pub session_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsSessionAuditInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let exclusive_session_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(exclusive_session_size) => exclusive_session_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(exclusive_session_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let session_digest_size = match self.session_digest.marshalled_size() {
            Ok(session_digest_size) => session_digest_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(session_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.exclusive_session.marshal(buf)?;

        let buf = self.session_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_exclusive_session) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_session_digest) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                exclusive_session: unmarshalled_exclusive_session,
                session_digest: unmarshalled_session_digest,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 132, table 127, TPMS_CREATION_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCreationInfo<'a> {
    pub object_name: Tpm2bName<'a>,
    pub creation_hash: Tpm2bDigest<'a>,
}

impl<'a> TpmsCreationInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let object_name_size = match self.object_name.marshalled_size() {
            Ok(object_name_size) => object_name_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(object_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let creation_hash_size = match self.creation_hash.marshalled_size() {
            Ok(creation_hash_size) => creation_hash_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(creation_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.object_name.marshal(buf)?;

        let buf = self.creation_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_name) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_creation_hash) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                object_name: unmarshalled_object_name,
                creation_hash: unmarshalled_creation_hash,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 132, table 128, TPMS_NV_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvCertifyInfo<'a> {
    pub index_name: Tpm2bName<'a>,
    pub offset: u16,
    pub nv_contents: Tpm2bMaxNvBuffer<'a>,
}

impl<'a> TpmsNvCertifyInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let index_name_size = match self.index_name.marshalled_size() {
            Ok(index_name_size) => index_name_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(index_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let nv_contents_size = match self.nv_contents.marshalled_size() {
            Ok(nv_contents_size) => nv_contents_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(nv_contents_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.index_name.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        let buf = self.nv_contents.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_index_name) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_nv_contents) =
            match Tpm2bMaxNvBuffer::<'_>::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        Ok((
            buf,
            Self {
                index_name: unmarshalled_index_name,
                offset: unmarshalled_offset,
                nv_contents: unmarshalled_nv_contents,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 133, table 129, TPMS_NV_DIGEST_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvDigestCertifyInfo<'a> {
    pub index_name: Tpm2bName<'a>,
    pub nv_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsNvDigestCertifyInfo<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let index_name_size = match self.index_name.marshalled_size() {
            Ok(index_name_size) => index_name_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(index_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let nv_digest_size = match self.nv_digest.marshalled_size() {
            Ok(nv_digest_size) => nv_digest_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(nv_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.index_name.marshal(buf)?;

        let buf = self.nv_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_index_name) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_nv_digest) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                index_name: unmarshalled_index_name,
                nv_digest: unmarshalled_nv_digest,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 133, table 130, TPMI_ST_ATTEST type
#[derive(Clone, Copy, Debug)]
struct TpmiStAttest {}

impl TpmiStAttest {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 134, table 132, TPMS_ATTEST structure
#[derive(Debug, PartialEq)]
pub struct TpmsAttest<'a> {
    pub magic: TpmGenerated,
    pub qualified_signer: Tpm2bName<'a>,
    pub extra_data: Tpm2bData<'a>,
    pub clock_info: TpmsClockInfo,
    pub firmware_version: u64,
    pub typ: TpmsAttestMemberTyp<'a>,
}

impl<'a> TpmsAttest<'a> {
    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let magic_size = match usize::try_from(TpmGenerated::marshalled_size()) {
            Ok(magic_size) => magic_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(magic_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let typ_selector_size =
            match usize::try_from(TpmsAttestMemberTyp::<'_>::marshalled_selector_size()) {
                Ok(typ_selector_size) => typ_selector_size,
                Err(_) => {
                    return Err(());
                }
            };
        size = match size.checked_add(typ_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let clock_info_size = match usize::try_from(tpms_clock_info_marshalled_size()) {
            Ok(clock_info_size) => clock_info_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(clock_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let firmware_version_size = mem::size_of::<u64>();
        size = match size.checked_add(firmware_version_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let qualified_signer_size = match self.qualified_signer.marshalled_size() {
            Ok(qualified_signer_size) => qualified_signer_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(qualified_signer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let extra_data_size = match self.extra_data.marshalled_size() {
            Ok(extra_data_size) => extra_data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(extra_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let typ_data_size = match self.typ.marshalled_data_size() {
            Ok(typ_data_size) => typ_data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(typ_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.magic.marshal(buf)?;

        let buf = self.typ.marshal_intern_selector(buf)?;

        let buf = self.qualified_signer.marshal(buf)?;

        let buf = self.extra_data.marshal(buf)?;

        let buf = self.clock_info.marshal(buf)?;

        let buf = marshal_u64(buf, self.firmware_version)?;

        let buf = self.typ.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_magic) = match TpmGenerated::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_typ_selector) =
            match TpmsAttestMemberTyp::<'_>::unmarshal_intern_selector(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        let (buf, unmarshalled_qualified_signer) = match Tpm2bName::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_extra_data) = match Tpm2bData::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_clock_info) = match TpmsClockInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_firmware_version) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_typ) = match TpmsAttestMemberTyp::<'_>::unmarshal_intern(
            unmarshalled_typ_selector,
            buf,
            limits,
        ) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                magic: unmarshalled_magic,
                qualified_signer: unmarshalled_qualified_signer,
                extra_data: unmarshalled_extra_data,
                clock_info: unmarshalled_clock_info,
                firmware_version: unmarshalled_firmware_version,
                typ: unmarshalled_typ,
            },
        ))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = Box::<Self>::new(unmarshalled);
        Ok((buf, unmarshalled))
    }
}

#[derive(Debug, PartialEq)]
#[repr(C, u16)]
pub enum TpmsAttestMemberTyp<'a> {
    AttestCertify(TpmsCertifyInfo<'a>) = TpmSt::AttestCertify as u16,
    AttestQuote(TpmsQuoteInfo<'a>) = TpmSt::AttestQuote as u16,
    AttestSessionAudit(TpmsSessionAuditInfo<'a>) = TpmSt::AttestSessionAudit as u16,
    AttestCommandAudit(TpmsCommandAuditInfo<'a>) = TpmSt::AttestCommandAudit as u16,
    AttestTime(TpmsTimeAttestInfo) = TpmSt::AttestTime as u16,
    AttestCreation(TpmsCreationInfo<'a>) = TpmSt::AttestCreation as u16,
    AttestNv(TpmsNvCertifyInfo<'a>) = TpmSt::AttestNv as u16,
    AttestNvDigest(TpmsNvDigestCertifyInfo<'a>) = TpmSt::AttestNvDigest as u16,
}

impl<'a> TpmsAttestMemberTyp<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiStAttest::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::AttestCertify(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestQuote(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestSessionAudit(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestCommandAudit(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestTime(_) => {
                let attested_size = match usize::try_from(tpms_time_attest_info_marshalled_size()) {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestCreation(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestNv(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::AttestNvDigest(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
        };

        Ok(size)
    }

    fn marshal_intern_selector<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let selector = match self {
            Self::AttestCertify(_) => TpmSt::AttestCertify as u16,
            Self::AttestQuote(_) => TpmSt::AttestQuote as u16,
            Self::AttestSessionAudit(_) => TpmSt::AttestSessionAudit as u16,
            Self::AttestCommandAudit(_) => TpmSt::AttestCommandAudit as u16,
            Self::AttestTime(_) => TpmSt::AttestTime as u16,
            Self::AttestCreation(_) => TpmSt::AttestCreation as u16,
            Self::AttestNv(_) => TpmSt::AttestNv as u16,
            Self::AttestNvDigest(_) => TpmSt::AttestNvDigest as u16,
        };

        marshal_u16(buf, selector)
    }

    fn marshal_intern_data<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::AttestCertify(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestQuote(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestSessionAudit(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestCommandAudit(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestTime(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestCreation(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestNv(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
            Self::AttestNvDigest(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern_selector(buf: &'a [u8]) -> Result<(&'a [u8], u16), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };
        Ok((buf, unmarshalled_typ_selector))
    }

    fn unmarshal_intern(
        selector: u16,
        buf: &'a [u8],
        limits: &TpmLimits,
    ) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, r) = match selector {
            value if value == TpmSt::AttestCertify as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsCertifyInfo::<'_>::unmarshal_intern(buf) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestCertify(unmarshalled_attested))
            }
            value if value == TpmSt::AttestQuote as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsQuoteInfo::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestQuote(unmarshalled_attested))
            }
            value if value == TpmSt::AttestSessionAudit as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsSessionAuditInfo::<'_>::unmarshal_intern(buf) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestSessionAudit(unmarshalled_attested))
            }
            value if value == TpmSt::AttestCommandAudit as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsCommandAuditInfo::<'_>::unmarshal_intern(buf) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestCommandAudit(unmarshalled_attested))
            }
            value if value == TpmSt::AttestTime as u16 => {
                let (buf, unmarshalled_attested) = match TpmsTimeAttestInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::AttestTime(unmarshalled_attested))
            }
            value if value == TpmSt::AttestCreation as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsCreationInfo::<'_>::unmarshal_intern(buf) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestCreation(unmarshalled_attested))
            }
            value if value == TpmSt::AttestNv as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsNvCertifyInfo::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestNv(unmarshalled_attested))
            }
            value if value == TpmSt::AttestNvDigest as u16 => {
                let (buf, unmarshalled_attested) =
                    match TpmsNvDigestCertifyInfo::<'_>::unmarshal_intern(buf) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::AttestNvDigest(unmarshalled_attested))
            }
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok((buf, r))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 136, table 136, expanded for tdes, TPMI_TDES_KEY_BITS type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiTdesKeyBits {
    pub value: u16,
}

impl TpmiTdesKeyBits {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self { value }));
        }

        if value == 192u16 {
            return Ok((buf, Self { value }));
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 136, table 136, expanded for aes, TPMI_AES_KEY_BITS type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiAesKeyBits {
    pub value: u16,
}

impl TpmiAesKeyBits {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self { value }));
        }

        if value == 192u16 {
            return Ok((buf, Self { value }));
        }

        if value == 256u16 {
            return Ok((buf, Self { value }));
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 136, table 136, expanded for sm4, TPMI_SM4_KEY_BITS type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiSm4KeyBits {
    pub value: u16,
}

impl TpmiSm4KeyBits {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self { value }));
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 136, table 136, expanded for camellia, TPMI_CAMELLIA_KEY_BITS type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiCamelliaKeyBits {
    pub value: u16,
}

impl TpmiCamelliaKeyBits {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self { value }));
        }

        if value == 192u16 {
            return Ok((buf, Self { value }));
        }

        if value == 256u16 {
            return Ok((buf, Self { value }));
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 138, table 141, TPMT_SYM_DEF_OBJECT structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtSymDefObject {
    Tdes {
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    Aes {
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    Sm4 {
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    Camellia {
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
}

impl TpmtSymDefObject {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSymObject::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Tdes {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Aes {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sm4 {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Camellia {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Tdes { key_bits, mode } => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Aes { key_bits, mode } => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Sm4 { key_bits, mode } => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Camellia { key_bits, mode } => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_algorithm {
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Tdes {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Aes {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Sm4 {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Camellia {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            }
        };

        Ok((buf, r))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 138, table 141, TPMT_SYM_DEF_OBJECT structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtSymDefObjectWCV {
    Tdes {
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    Aes {
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    Sm4 {
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    Camellia {
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtSymDefObjectWCV {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSymObjectWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Tdes {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Aes {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sm4 {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Camellia {
                key_bits: _,
                mode: _,
            } => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Null => (),
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Tdes { key_bits, mode } => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Aes { key_bits, mode } => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Sm4 { key_bits, mode } => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Camellia { key_bits, mode } => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            }
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_algorithm {
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Tdes {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Aes {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Sm4 {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Camellia {
                        key_bits: unmarshalled_key_bits,
                        mode: unmarshalled_mode,
                    },
                )
            }
            value if value == TpmAlgId::Null as u16 => (buf, Self::Null),
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            }
        };

        Ok((buf, r))
    }
}

impl convert::From<TpmtSymDefObject> for TpmtSymDefObjectWCV {
    fn from(value: TpmtSymDefObject) -> Self {
        match value {
            TpmtSymDefObject::Tdes { key_bits, mode } => Self::Tdes { key_bits, mode },
            TpmtSymDefObject::Aes { key_bits, mode } => Self::Aes { key_bits, mode },
            TpmtSymDefObject::Sm4 { key_bits, mode } => Self::Sm4 { key_bits, mode },
            TpmtSymDefObject::Camellia { key_bits, mode } => Self::Camellia { key_bits, mode },
        }
    }
}

impl convert::TryFrom<TpmtSymDefObjectWCV> for TpmtSymDefObject {
    type Error = TpmErr;

    fn try_from(value: TpmtSymDefObjectWCV) -> Result<Self, TpmErr> {
        let result = match value {
            TpmtSymDefObjectWCV::Tdes { key_bits, mode } => Self::Tdes { key_bits, mode },
            TpmtSymDefObjectWCV::Aes { key_bits, mode } => Self::Aes { key_bits, mode },
            TpmtSymDefObjectWCV::Sm4 { key_bits, mode } => Self::Sm4 { key_bits, mode },
            TpmtSymDefObjectWCV::Camellia { key_bits, mode } => Self::Camellia { key_bits, mode },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            }
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtSymDefObject> for TpmtSymDefObjectWCV {
    fn eq(&self, other: &TpmtSymDefObject) -> bool {
        match self {
            Self::Tdes {
                key_bits: self_key_bits,
                mode: self_mode,
            } => {
                if let TpmtSymDefObject::Tdes {
                    key_bits: other_key_bits,
                    mode: other_mode,
                } = other
                {
                    self_key_bits == other_key_bits && self_mode == other_mode
                } else {
                    false
                }
            }
            Self::Aes {
                key_bits: self_key_bits,
                mode: self_mode,
            } => {
                if let TpmtSymDefObject::Aes {
                    key_bits: other_key_bits,
                    mode: other_mode,
                } = other
                {
                    self_key_bits == other_key_bits && self_mode == other_mode
                } else {
                    false
                }
            }
            Self::Sm4 {
                key_bits: self_key_bits,
                mode: self_mode,
            } => {
                if let TpmtSymDefObject::Sm4 {
                    key_bits: other_key_bits,
                    mode: other_mode,
                } = other
                {
                    self_key_bits == other_key_bits && self_mode == other_mode
                } else {
                    false
                }
            }
            Self::Camellia {
                key_bits: self_key_bits,
                mode: self_mode,
            } => {
                if let TpmtSymDefObject::Camellia {
                    key_bits: other_key_bits,
                    mode: other_mode,
                } = other
                {
                    self_key_bits == other_key_bits && self_mode == other_mode
                } else {
                    false
                }
            }
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtSymDefObjectWCV> for TpmtSymDefObject {
    fn eq(&self, other: &TpmtSymDefObjectWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 139, table 143, TPMS_SYMCIPHER_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSymcipherParms {
    pub sym: TpmtSymDefObject,
}

impl TpmsSymcipherParms {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let sym_size = match self.sym.marshalled_size() {
            Ok(sym_size) => sym_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(sym_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sym.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sym) = match TpmtSymDefObject::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                sym: unmarshalled_sym,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 141, table 151, TPMS_SCHEME_HASH structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeHash {
    pub hash_alg: TpmiAlgHash,
}

impl TpmsSchemeHash {
    const fn marshalled_size() -> u16 {
        tpms_scheme_hash_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                hash_alg: unmarshalled_hash_alg,
            },
        ))
    }
}

const fn tpms_scheme_hash_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 142, table 152, TPMS_SCHEME_ECDAA structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeEcdaa {
    pub hash_alg: TpmiAlgHash,
    pub count: u16,
}

impl TpmsSchemeEcdaa {
    const fn marshalled_size() -> u16 {
        tpms_scheme_ecdaa_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        let buf = marshal_u16(buf, self.count)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_count) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                hash_alg: unmarshalled_hash_alg,
                count: unmarshalled_count,
            },
        ))
    }
}

const fn tpms_scheme_ecdaa_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 142, table 153, TPMI_ALG_KEYEDHASH_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgKeyedhashSchemeWCV {}

impl TpmiAlgKeyedhashSchemeWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 142, table 155, TPMS_SCHEME_XOR structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeXor {
    pub hash_alg: TpmiAlgHash,
    pub kdf: TpmiAlgKdfWCV,
}

impl TpmsSchemeXor {
    const fn marshalled_size() -> u16 {
        tpms_scheme_xor_marshalled_size()
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        let buf = self.kdf.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_kdf) = match TpmiAlgKdfWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                hash_alg: unmarshalled_hash_alg,
                kdf: unmarshalled_kdf,
            },
        ))
    }
}

const fn tpms_scheme_xor_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += TpmiAlgKdfWCV::marshalled_size();

    size
}

// TCG TPM2 Library (rev 01.59), Part 2, page 143, table 157, TPMT_KEYEDHASH_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtKeyedhashSchemeWCV {
    Hmac(TpmsSchemeHash) = TpmAlgId::Hmac as u16,
    Xor(TpmsSchemeXor) = TpmAlgId::Xor as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtKeyedhashSchemeWCV {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKeyedhashSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Hmac(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Xor(_) => {
                let details_size = match usize::try_from(tpms_scheme_xor_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Null => (),
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Hmac(details) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Xor(details) => {
                let selector = TpmAlgId::Xor as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_scheme {
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Hmac(unmarshalled_details))
            }
            value if value == TpmAlgId::Xor as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeXor::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Xor(unmarshalled_details))
            }
            value if value == TpmAlgId::Null as u16 => (buf, Self::Null),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok((buf, r))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 146, table 166, TPMT_KDF_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtKdfSchemeWCV {
    Mgf1(TpmsSchemeHash) = TpmAlgId::Mgf1 as u16,
    Kdf1Sp800_56a(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_56a as u16,
    Kdf2(TpmsSchemeHash) = TpmAlgId::Kdf2 as u16,
    Kdf1Sp800_108(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_108 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtKdfSchemeWCV {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKdfWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Mgf1(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Kdf1Sp800_56a(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Kdf2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Kdf1Sp800_108(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Null => (),
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Mgf1(details) => {
                let selector = TpmAlgId::Mgf1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Kdf1Sp800_56a(details) => {
                let selector = TpmAlgId::Kdf1Sp800_56a as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Kdf2(details) => {
                let selector = TpmAlgId::Kdf2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Kdf1Sp800_108(details) => {
                let selector = TpmAlgId::Kdf1Sp800_108 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_scheme {
            value if value == TpmAlgId::Mgf1 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Mgf1(unmarshalled_details))
            }
            value if value == TpmAlgId::Kdf1Sp800_56a as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Kdf1Sp800_56a(unmarshalled_details))
            }
            value if value == TpmAlgId::Kdf2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Kdf2(unmarshalled_details))
            }
            value if value == TpmAlgId::Kdf1Sp800_108 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Kdf1Sp800_108(unmarshalled_details))
            }
            value if value == TpmAlgId::Null as u16 => (buf, Self::Null),
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            }
        };

        Ok((buf, r))
    }
}

impl convert::From<&TpmtKdfSchemeWCV> for TpmiAlgKdfWCV {
    fn from(value: &TpmtKdfSchemeWCV) -> Self {
        match value {
            TpmtKdfSchemeWCV::Mgf1(_) => Self::Mgf1,
            TpmtKdfSchemeWCV::Kdf1Sp800_56a(_) => Self::Kdf1Sp800_56a,
            TpmtKdfSchemeWCV::Kdf2(_) => Self::Kdf2,
            TpmtKdfSchemeWCV::Kdf1Sp800_108(_) => Self::Kdf1Sp800_108,
            TpmtKdfSchemeWCV::Null => Self::Null,
        }
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 148, table 170, TPMI_ALG_RSA_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgRsaSchemeWCV {}

impl TpmiAlgRsaSchemeWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 148, table 171, TPMT_RSA_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtRsaSchemeWCV {
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtRsaSchemeWCV {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgRsaSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Null => (),
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_scheme {
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Rsassa(unmarshalled_details))
            }
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Rsaes(unmarshalled_details))
            }
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Rsapss(unmarshalled_details))
            }
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Oaep(unmarshalled_details))
            }
            value if value == TpmAlgId::Null as u16 => (buf, Self::Null),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok((buf, r))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 149, table 174, TPM2B_PUBLIC_KEY_RSA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bPublicKeyRsa<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bPublicKeyRsa<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_rsa_key_bytes {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((
            buf,
            Self {
                buffer: unmarshalled_buffer,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 149, table 175, TPMI_RSA_KEY_BITS type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiRsaKeyBits {
    Bits1024 = RsaKeyBits::Bits1024 as u16,
    Bits2048 = RsaKeyBits::Bits2048 as u16,
    Bits3072 = RsaKeyBits::Bits3072 as u16,
    Bits4096 = RsaKeyBits::Bits4096 as u16,
    Bits8192 = RsaKeyBits::Bits8192 as u16,
    Bits16384 = RsaKeyBits::Bits16384 as u16,
}

impl TpmiRsaKeyBits {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiRsaKeyBits {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Bits1024 as u16 => Self::Bits1024,
            value if value == Self::Bits2048 as u16 => Self::Bits2048,
            value if value == Self::Bits3072 as u16 => Self::Bits3072,
            value if value == Self::Bits4096 as u16 => Self::Bits4096,
            value if value == Self::Bits8192 as u16 => Self::Bits8192,
            value if value == Self::Bits16384 as u16 => Self::Bits16384,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 150, table 177, TPM2B_ECC_PARAMETER structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bEccParameter<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bEccParameter<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            }
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match limits.max_ecc_key_bytes() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            }
        };
        if buffer_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            }
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            }
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((
            buf,
            Self {
                buffer: unmarshalled_buffer,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 150, table 178, TPMS_ECC_POINT structure
#[derive(Debug, PartialEq)]
pub struct TpmsEccPoint<'a> {
    pub x: Tpm2bEccParameter<'a>,
    pub y: Tpm2bEccParameter<'a>,
}

impl<'a> TpmsEccPoint<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let x_size = match self.x.marshalled_size() {
            Ok(x_size) => x_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(x_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let y_size = match self.y.marshalled_size() {
            Ok(y_size) => y_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(y_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.x.marshal(buf)?;

        let buf = self.y.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_x) = match Tpm2bEccParameter::<'_>::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_y) = match Tpm2bEccParameter::<'_>::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                x: unmarshalled_x,
                y: unmarshalled_y,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 151, table 180, TPMI_ALG_ECC_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug)]
struct TpmiAlgEccSchemeWCV {}

impl TpmiAlgEccSchemeWCV {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 151, table 181, TPMI_ECC_CURVE type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiEccCurve {
    NistP192 = TpmEccCurve::NistP192 as u16,
    NistP224 = TpmEccCurve::NistP224 as u16,
    NistP256 = TpmEccCurve::NistP256 as u16,
    NistP384 = TpmEccCurve::NistP384 as u16,
    NistP521 = TpmEccCurve::NistP521 as u16,
    BnP256 = TpmEccCurve::BnP256 as u16,
    BnP638 = TpmEccCurve::BnP638 as u16,
    Sm2P256 = TpmEccCurve::Sm2P256 as u16,
    BpP256R1 = TpmEccCurve::BpP256R1 as u16,
    BpP384R1 = TpmEccCurve::BpP384R1 as u16,
    BpP512R1 = TpmEccCurve::BpP512R1 as u16,
    Curve25519 = TpmEccCurve::Curve25519 as u16,
}

impl TpmiEccCurve {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiEccCurve {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::NistP192 as u16 => Self::NistP192,
            value if value == Self::NistP224 as u16 => Self::NistP224,
            value if value == Self::NistP256 as u16 => Self::NistP256,
            value if value == Self::NistP384 as u16 => Self::NistP384,
            value if value == Self::NistP521 as u16 => Self::NistP521,
            value if value == Self::BnP256 as u16 => Self::BnP256,
            value if value == Self::BnP638 as u16 => Self::BnP638,
            value if value == Self::Sm2P256 as u16 => Self::Sm2P256,
            value if value == Self::BpP256R1 as u16 => Self::BpP256R1,
            value if value == Self::BpP384R1 as u16 => Self::BpP384R1,
            value if value == Self::BpP512R1 as u16 => Self::BpP512R1,
            value if value == Self::Curve25519 as u16 => Self::Curve25519,
            _ => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            }
        };

        Ok(result)
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 151, table 182, TPMT_ECC_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, u16)]
pub enum TpmtEccSchemeWCV {
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    Ecdh(TpmsSchemeHash) = TpmAlgId::Ecdh as u16,
    Ecmqv(TpmsSchemeHash) = TpmAlgId::Ecmqv as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtEccSchemeWCV {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgEccSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecdh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecmqv(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Null => (),
        };

        Ok(size)
    }

    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Ecdh(details) => {
                let selector = TpmAlgId::Ecdh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Ecmqv(details) => {
                let selector = TpmAlgId::Ecmqv as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            }
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_scheme {
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            }
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            }
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Sm2(unmarshalled_details))
            }
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            }
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Eddsa(unmarshalled_details))
            }
            value if value == TpmAlgId::Ecdh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Ecdh(unmarshalled_details))
            }
            value if value == TpmAlgId::Ecmqv as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Ecmqv(unmarshalled_details))
            }
            value if value == TpmAlgId::Null as u16 => (buf, Self::Null),
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            }
        };

        Ok((buf, r))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 152, table 184, TPMS_SIGNATURE_RSA structure
#[derive(Debug, PartialEq)]
pub struct TpmsSignatureRsa<'a> {
    pub hash: TpmiAlgHash,
    pub sig: Tpm2bPublicKeyRsa<'a>,
}

impl<'a> TpmsSignatureRsa<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let sig_size = match self.sig.marshalled_size() {
            Ok(sig_size) => sig_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(sig_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let buf = self.sig.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_sig) = match Tpm2bPublicKeyRsa::<'_>::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                hash: unmarshalled_hash,
                sig: unmarshalled_sig,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 153, table 186, TPMS_SIGNATURE_ECC structure
#[derive(Debug, PartialEq)]
pub struct TpmsSignatureEcc<'a> {
    pub hash: TpmiAlgHash,
    pub signature_r: Tpm2bEccParameter<'a>,
    pub signature_s: Tpm2bEccParameter<'a>,
}

impl<'a> TpmsSignatureEcc<'a> {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let signature_r_size = match self.signature_r.marshalled_size() {
            Ok(signature_r_size) => signature_r_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(signature_r_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let signature_s_size = match self.signature_s.marshalled_size() {
            Ok(signature_s_size) => signature_s_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(signature_s_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let buf = self.signature_r.marshal(buf)?;

        let buf = self.signature_s.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_signature_r) =
            match Tpm2bEccParameter::<'_>::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        let (buf, unmarshalled_signature_s) =
            match Tpm2bEccParameter::<'_>::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        Ok((
            buf,
            Self {
                hash: unmarshalled_hash,
                signature_r: unmarshalled_signature_r,
                signature_s: unmarshalled_signature_s,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 153, table 189, TPMT_SIGNATURE structure (without conditional values)
#[derive(Debug, PartialEq, Kinded)]
#[repr(C, u16)]
pub enum TpmtSignature<'a> {
    Rsassa(TpmsSignatureRsa<'a>) = TpmAlgId::Rsassa as u16,
    Rsapss(TpmsSignatureRsa<'a>) = TpmAlgId::Rsapss as u16,
    Ecdsa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdsa as u16,
    Ecdaa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdaa as u16,
    Sm2(TpmsSignatureEcc<'a>) = TpmAlgId::Sm2 as u16,
    Ecschnorr(TpmsSignatureEcc<'a>) = TpmAlgId::Ecschnorr as u16,
    Eddsa(TpmsSignatureEcc<'a>) = TpmAlgId::Eddsa as u16,
    Hmac(TpmtHa<'a>) = TpmAlgId::Hmac as u16,
}

impl<'a> TpmtSignature<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSigScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Rsassa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Rsapss(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecdsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecdaa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Sm2(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecschnorr(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Eddsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Hmac(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::Rsassa(signature) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Rsapss(signature) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Ecdsa(signature) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Ecdaa(signature) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Sm2(signature) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Ecschnorr(signature) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Eddsa(signature) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
            Self::Hmac(signature) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sig_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, r) = match unmarshalled_sig_alg {
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureRsa::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Rsassa(unmarshalled_signature))
            }
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureRsa::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Rsapss(unmarshalled_signature))
            }
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureEcc::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Ecdsa(unmarshalled_signature))
            }
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureEcc::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Ecdaa(unmarshalled_signature))
            }
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureEcc::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Sm2(unmarshalled_signature))
            }
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureEcc::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Ecschnorr(unmarshalled_signature))
            }
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_signature) =
                    match TpmsSignatureEcc::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (buf, Self::Eddsa(unmarshalled_signature))
            }
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_signature) = match TpmtHa::<'_>::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (buf, Self::Hmac(unmarshalled_signature))
            }
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            }
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = Box::<Self>::new(unmarshalled);

        Ok((buf, unmarshalled))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 155, table 192, TPMI_ALG_PUBLIC type
#[derive(Clone, Copy, Debug)]
struct TpmiAlgPublic {}

impl TpmiAlgPublic {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 157, table 194, TPMS_KEYEDHASH_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsKeyedhashParms {
    pub scheme: TpmtKeyedhashSchemeWCV,
}

impl TpmsKeyedhashParms {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match TpmtKeyedhashSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                scheme: unmarshalled_scheme,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 158, table 196, TPMS_RSA_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsRsaParms {
    pub symmetric: TpmtSymDefObjectWCV,
    pub scheme: TpmtRsaSchemeWCV,
    pub key_bits: TpmiRsaKeyBits,
    pub exponent: u32,
}

impl TpmsRsaParms {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let key_bits_size = match usize::try_from(TpmiRsaKeyBits::marshalled_size()) {
            Ok(key_bits_size) => key_bits_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(key_bits_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let exponent_size = mem::size_of::<u32>();
        size = match size.checked_add(exponent_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.symmetric.marshal(buf)?;

        let buf = self.scheme.marshal(buf)?;

        let buf = self.key_bits.marshal(buf)?;

        let buf = marshal_u32(buf, self.exponent)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_symmetric) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_scheme) = match TpmtRsaSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_key_bits) = match TpmiRsaKeyBits::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_exponent) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                symmetric: unmarshalled_symmetric,
                scheme: unmarshalled_scheme,
                key_bits: unmarshalled_key_bits,
                exponent: unmarshalled_exponent,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 159, table 197, TPMS_ECC_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsEccParms {
    pub symmetric: TpmtSymDefObjectWCV,
    pub scheme: TpmtEccSchemeWCV,
    pub curve_id: TpmiEccCurve,
    pub kdf: TpmtKdfSchemeWCV,
}

impl TpmsEccParms {
    fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let curve_id_size = match usize::try_from(TpmiEccCurve::marshalled_size()) {
            Ok(curve_id_size) => curve_id_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(curve_id_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let kdf_size = match self.kdf.marshalled_size() {
            Ok(kdf_size) => kdf_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(kdf_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.symmetric.marshal(buf)?;

        let buf = self.scheme.marshal(buf)?;

        let buf = self.curve_id.marshal(buf)?;

        let buf = self.kdf.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_symmetric) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_scheme) = match TpmtEccSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_curve_id) = match TpmiEccCurve::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_kdf) = match TpmtKdfSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                symmetric: unmarshalled_symmetric,
                scheme: unmarshalled_scheme,
                curve_id: unmarshalled_curve_id,
                kdf: unmarshalled_kdf,
            },
        ))
    }
}

// TCG TPM2 Library (rev 01.59), Part 2, page 160, table 200, TPMT_PUBLIC structure (without conditional values)
#[derive(Debug, PartialEq)]
pub struct TpmtPublic<'a> {
    pub name_alg: TpmiAlgHash,
    pub object_attributes: TpmaObject,
    pub auth_policy: Tpm2bDigest<'a>,
    pub typ: TpmtPublicMemberTyp<'a>,
}

impl<'a> TpmtPublic<'a> {
    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let typ_selector_size =
            match usize::try_from(TpmtPublicMemberTyp::marshalled_selector_size()) {
                Ok(typ_selector_size) => typ_selector_size,
                Err(_) => {
                    return Err(());
                }
            };
        size = match size.checked_add(typ_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let name_alg_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(name_alg_size) => name_alg_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let object_attributes_size = match usize::try_from(TpmaObject::marshalled_size()) {
            Ok(object_attributes_size) => object_attributes_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(object_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        let typ_data_size = match self.typ.marshalled_data_size() {
            Ok(typ_data_size) => typ_data_size,
            Err(_) => {
                return Err(());
            }
        };
        size = match size.checked_add(typ_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            }
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.typ.marshal_intern_selector(buf)?;

        let buf = self.name_alg.marshal(buf)?;

        let buf = self.object_attributes.marshal(buf)?;

        let buf = self.auth_policy.marshal(buf)?;

        let buf = self.typ.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_typ_selector) =
            match TpmtPublicMemberTyp::<'_>::unmarshal_intern_selector(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                }
            };

        let (buf, unmarshalled_name_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_object_attributes) = match TpmaObject::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        let (buf, unmarshalled_typ) = match TpmtPublicMemberTyp::<'_>::unmarshal_intern(
            unmarshalled_typ_selector,
            buf,
            limits,
        ) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok((
            buf,
            Self {
                name_alg: unmarshalled_name_alg,
                object_attributes: unmarshalled_object_attributes,
                auth_policy: unmarshalled_auth_policy,
                typ: unmarshalled_typ,
            },
        ))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = Box::<Self>::new(unmarshalled);
        Ok((buf, unmarshalled))
    }
}

#[derive(Debug, PartialEq)]
#[repr(C, u16)]
pub enum TpmtPublicMemberTyp<'a> {
    Rsa {
        parameters: TpmsRsaParms,
        unique: Tpm2bPublicKeyRsa<'a>,
    } = TpmAlgId::Rsa as u16,
    Keyedhash {
        parameters: TpmsKeyedhashParms,
        unique: Tpm2bDigest<'a>,
    } = TpmAlgId::Keyedhash as u16,
    Ecc {
        parameters: TpmsEccParms,
        unique: TpmsEccPoint<'a>,
    } = TpmAlgId::Ecc as u16,
    Symcipher {
        parameters: TpmsSymcipherParms,
        unique: Tpm2bDigest<'a>,
    } = TpmAlgId::Symcipher as u16,
}

impl<'a> TpmtPublicMemberTyp<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgPublic::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Rsa { parameters, unique } => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Keyedhash { parameters, unique } => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Ecc { parameters, unique } => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
            Self::Symcipher { parameters, unique } => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    }
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    }
                };
            }
        };

        Ok(size)
    }

    fn marshal_intern_selector<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let selector = match self {
            Self::Rsa {
                parameters: _,
                unique: _,
            } => TpmAlgId::Rsa as u16,
            Self::Keyedhash {
                parameters: _,
                unique: _,
            } => TpmAlgId::Keyedhash as u16,
            Self::Ecc {
                parameters: _,
                unique: _,
            } => TpmAlgId::Ecc as u16,
            Self::Symcipher {
                parameters: _,
                unique: _,
            } => TpmAlgId::Symcipher as u16,
        };

        marshal_u16(buf, selector)
    }

    fn marshal_intern_data<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::Rsa { parameters, unique } => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            }
            Self::Keyedhash { parameters, unique } => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            }
            Self::Ecc { parameters, unique } => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            }
            Self::Symcipher { parameters, unique } => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            }
        };
        Ok(buf)
    }

    fn unmarshal_intern_selector(buf: &'a [u8]) -> Result<(&'a [u8], u16), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };
        Ok((buf, unmarshalled_typ_selector))
    }

    fn unmarshal_intern(
        selector: u16,
        buf: &'a [u8],
        limits: &TpmLimits,
    ) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, r) = match selector {
            value if value == TpmAlgId::Rsa as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsRsaParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_unique) =
                    match Tpm2bPublicKeyRsa::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (
                    buf,
                    Self::Rsa {
                        parameters: unmarshalled_parameters,
                        unique: unmarshalled_unique,
                    },
                )
            }
            value if value == TpmAlgId::Keyedhash as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsKeyedhashParms::unmarshal_intern(buf)
                {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_unique) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Keyedhash {
                        parameters: unmarshalled_parameters,
                        unique: unmarshalled_unique,
                    },
                )
            }
            value if value == TpmAlgId::Ecc as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsEccParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_unique) =
                    match TpmsEccPoint::<'_>::unmarshal_intern(buf, limits) {
                        Ok(r) => r,
                        Err(e) => {
                            return Err(e);
                        }
                    };

                (
                    buf,
                    Self::Ecc {
                        parameters: unmarshalled_parameters,
                        unique: unmarshalled_unique,
                    },
                )
            }
            value if value == TpmAlgId::Symcipher as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsSymcipherParms::unmarshal_intern(buf)
                {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                let (buf, unmarshalled_unique) = match Tpm2bDigest::<'_>::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    }
                };

                (
                    buf,
                    Self::Symcipher {
                        parameters: unmarshalled_parameters,
                        unique: unmarshalled_unique,
                    },
                )
            }
            _ => {
                return Err(TpmErr::Rc(TpmRc::TYPE));
            }
        };

        Ok((buf, r))
    }
}

// Vendor amendment to TCG Algorithm Registry, RSA_KEY_BITS constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
enum RsaKeyBits {
    Bits1024 = 1024u16,
    Bits2048 = 2048u16,
    Bits3072 = 3072u16,
    Bits4096 = 4096u16,
    Bits8192 = 8192u16,
    Bits16384 = 16384u16,
}
