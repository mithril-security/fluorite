name: Testing Pipeline Azure

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  VERSION: 0.1.0
  ZONE_NAME: test.mithrilsecurity.io
  AZURE_COMMUNITY_GALLERY_ID: "/CommunityGalleries/FluoriteOS-34c46669-97d8-4ac7-adcf-2d18e6662797/Images"
jobs:
  test:
    runs-on: fluorite-runner
    timeout-minutes: 60
    strategy:
      # Use fail-fast: false so if one test fails, the other continues
      fail-fast: false
      matrix:
        include:
          - job_id: test-nginx-self-ca
            package: nginx-self-ca
            include_ca: false
            vm_location: francecentral
            vm_type: Standard_D4as_v4
            attestation_backend: AzureTrustedLaunchVM
            gpu: false
          - job_id: test-nginx
            package: nginx
            include_ca: true
            vm_location: eastus2
            vm_type: Standard_D4as_v4
            attestation_backend: AzureTrustedLaunchVM
            gpu: false
          - job_id: test-ray-tl
            package: ray-tl
            include_ca: true
            vm_location: francecentral
            vm_type: Standard_NC24ads_A100_v4
            attestation_backend: AzureTrustedLaunchVM
            gpu: true
          - job_id: test-ray
            package: ray
            include_ca: true
            vm_location: eastus2
            vm_type: Standard_NCC40ads_H100_v5
            attestation_backend: AzureConfidentialVM
            gpu: true
    env:
      PACKAGE: ${{ matrix.package }}
      # We use job_id from matrix instead of github.job to stay consistent
      AZURE_CONFIG_DIR: /home/ubuntu/.azure-gha-${{ github.run_id }}-${{ github.run_attempt }}-${{ strategy.job-index }}
      JOB_NAME: az-${{ matrix.job_id }}
      VM_LOCATION: ${{ matrix.vm_location }}
      VM_TYPE: ${{ matrix.vm_type }}
      ATTESTATION_BACKEND: ${{ matrix.attestation_backend }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Hostname and create Job dir
        run: |
          echo "HOSTNAME=${{ env.JOB_NAME }}.${{ env.ZONE_NAME }}" >> $GITHUB_ENV
          mkdir -p "${{ github.workspace }}/${{ github.run_id }}-${{ github.run_attempt }}/${{ env.JOB_NAME }}"
          echo "DIR=${{ github.workspace }}/${{ github.run_id }}-${{ github.run_attempt }}/${{ env.JOB_NAME }}" >> $GITHUB_ENV

      - name: Get provisioning bundle
        run: |
          mkdir ${{ env.DIR }}/packages

          PACKAGE_NAME="zarf-package-${{ env.PACKAGE }}-amd64-0.1.0.tar.zst"
          PACKAGE_URL="https://storage.googleapis.com/fluorite/provisioning-bundles/${{ env.PACKAGE }}/${{ env.VERSION }}/$PACKAGE_NAME"
          PACKAGE_PATH="${{ env.DIR }}/packages/$PACKAGE_NAME"

          curl $PACKAGE_URL -o $PACKAGE_PATH

          echo "PACKAGE_PATH=$PACKAGE_PATH" >> $GITHUB_ENV

          # Compute the hash of the provisioning package
          BUNDLE_HASH=$(sha256sum $PACKAGE_PATH | awk '{print $1}')
          echo "BUNDLE_HASH=$BUNDLE_HASH" >> $GITHUB_ENV

          echo "PACKAGE_URL=$PACKAGE_URL" >> $GITHUB_ENV

      - name: Get pre-built binaries
        run: |
          mkdir -p ${{ env.DIR }}/binaries
          curl https://storage.googleapis.com/fluorite/${{ env.VERSION }}/binaries/client -o ${{ env.DIR }}/binaries/client
          curl https://storage.googleapis.com/fluorite/${{ env.VERSION }}/binaries/fluorite -o ${{ env.DIR }}/binaries/fluorite

          chmod +x ${{ env.DIR }}/binaries/*

      - name: Generate Operator Certificates
        run: |
          ${{ env.DIR }}/binaries/fluorite generate-certificates --force --cert-directory-path ${{ env.DIR }}/certificates

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Inject variables in the job environment
        run: |

          VERSION_FORMATTED="${VERSION//./-}"

          if [ "${{ matrix.gpu }}" = "false" ]; then
            echo "AZURE_IMAGE=${{ env.AZURE_COMMUNITY_GALLERY_ID }}/fluorite-os-${VERSION_FORMATTED}/Versions/0.1.0" >> $GITHUB_ENV
            MEASUREMENT_URL="https://storage.googleapis.com/fluorite/${{ env.VERSION }}/fluorite-os/cloud-vtpm/os-measurement.json"
            OS_DISK_URL="https://storage.googleapis.com/fluorite/${{ env.VERSION }}/fluorite-os/cloud-vtpm/disk.raw"
          else
            echo "AZURE_IMAGE=${{ env.AZURE_COMMUNITY_GALLERY_ID }}/fluorite-os-with-gpu-${VERSION_FORMATTED}/Versions/0.1.0" >> $GITHUB_ENV
            MEASUREMENT_URL="https://storage.googleapis.com/fluorite/${{ env.VERSION }}/fluorite-os/cloud-vtpm-with-gpu/os-measurement.json"
            OS_DISK_URL="https://storage.googleapis.com/fluorite/${{ env.VERSION }}/fluorite-os/cloud-vtpm-with-gpu/disk.raw"
          fi
          # Get the latest FluoriteOS image published on Azure Image Gallery and it's PCR4 Golden Value
          OS_MEASUREMENT=$(curl $MEASUREMENT_URL | jq -r .fluoriteos_pcr4)
          echo "OS_MEASUREMENT=$OS_MEASUREMENT" >> $GITHUB_ENV
          echo "OS_DISK_URL=$OS_DISK_URL" >> $GITHUB_ENV

          PLATFORM_MEASUREMENTS_PATH="./measurements/measurements_azure.json"
          echo "PLATFORM_MEASUREMENTS_PATH=$PLATFORM_MEASUREMENTS_PATH" >> $GITHUB_ENV

          OPERATOR_CERTIFICATE_PATH="${{ env.DIR }}/certificates/cert.pem"
          echo "OPERATOR_CERTIFICATE_PATH=$OPERATOR_CERTIFICATE_PATH" >> $GITHUB_ENV

          OPERATOR_PRIVATE_KEY_PATH="${{ env.DIR }}/certificates/key.pem"
          echo "OPERATOR_PRIVATE_KEY_PATH=$OPERATOR_PRIVATE_KEY_PATH" >> $GITHUB_ENV

          DEPLOYMENT_CONFIG_PATH="${{ env.DIR }}/deployment_config.yaml"
          echo "DEPLOYMENT_CONFIG_PATH=$DEPLOYMENT_CONFIG_PATH" >> $GITHUB_ENV

          if [ "${{ matrix.include_ca }}" = "true" ]; then
            # Generate the password for the Attestation Transparency Service
            ATS_PASSWORD=$(openssl rand -hex 32)
            echo "::add-mask::$ATS_PASSWORD"        
            echo "ATS_PASSWORD=$ATS_PASSWORD" >> $GITHUB_ENV

            # Encode the operator certificate for the next jobs
            OPERATOR_CERTIFICATE_B64=$(base64 -w0 $OPERATOR_CERTIFICATE_PATH)
            echo "OPERATOR_CERTIFICATE_B64=$OPERATOR_CERTIFICATE_B64" >> $GITHUB_ENV

            ATS_ENDPOINT="https://ats.${{ env.HOSTNAME }}/verify_csr"
            echo "ATS_ENDPOINT=$ATS_ENDPOINT" >> $GITHUB_ENV

            ATS_CONTAINER_APP_NAME="ats-app-${{ env.JOB_NAME }}"
            echo "ATS_CONTAINER_APP_NAME=$ATS_CONTAINER_APP_NAME" >> $GITHUB_ENV

            ATS_CONTAINER_APP_ENVIRONMENT="ats-env-${{ env.JOB_NAME }}"
            echo "ATS_CONTAINER_APP_ENVIRONMENT=$ATS_CONTAINER_APP_ENVIRONMENT" >> $GITHUB_ENV

            DOMAIN_MONITOR_CONTAINER_APP_NAME="dom-mon-app-${{ env.JOB_NAME }}"
            echo "DOMAIN_MONITOR_CONTAINER_APP_NAME=$DOMAIN_MONITOR_CONTAINER_APP_NAME" >> $GITHUB_ENV

            DOMAIN_MONITOR_CONTAINER_APP_ENVIRONMENT="dom-mon-env-${{ env.JOB_NAME }}"
            echo "DOMAIN_MONITOR_CONTAINER_APP_ENVIRONMENT=$DOMAIN_MONITOR_CONTAINER_APP_ENVIRONMENT" >> $GITHUB_ENV

            BLOB_STORAGE_URL="https://proofs.demo.mithrilsecurity.io/"
            echo "BLOB_STORAGE_URL=$BLOB_STORAGE_URL" >> $GITHUB_ENV
          fi

          RESOURCE_GROUP="ivan-fli-multinode"
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Create deployment config file
        run: |
          cat << EOF > ${{ env.DEPLOYMENT_CONFIG_PATH }}
          package:
            deploy:
              set:
          EOF

          yq -iy '.package.deploy.set.HOSTNAME = "${{ env.HOSTNAME }}"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
          if [ "${{ matrix.include_ca }}" = "true" ]; then
            yq -iy '.package.deploy.set.ATS_PASSWORD = "${{ env.ATS_PASSWORD }}"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
            yq -iy '.package.deploy.set.PUBLIC_CA_KEY = "${{ secrets.PUBLIC_CA_KEY }}"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
            yq -iy '.package.deploy.set.PUBLIC_CA_EMAIL = "${{ secrets.PUBLIC_CA_EMAIL }}"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
            yq -iy '.package.deploy.set.ATS_ENDPOINT = "${{ env.ATS_ENDPOINT }}"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
          fi

          if [ "${{ matrix.gpu }}" = "true" ]; then
            # NODES: 2. We have 1 control plane node and one agent node
            yq -iy '.package.deploy.set.NODES = "2"' ${{ env.DEPLOYMENT_CONFIG_PATH }}
          fi

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build and deploy Attestation Transparency Service Container App
        if: matrix.include_ca == true
        uses: azure/container-apps-deploy-action@v2
        with:
          imageToDeploy: fluorite.azurecr.io/attestation-transparency-service:${{ env.VERSION }}
          containerAppName: ${{ env.ATS_CONTAINER_APP_NAME }}
          containerAppEnvironment: ${{ env.ATS_CONTAINER_APP_ENVIRONMENT }}
          resourceGroup: ${{ env.RESOURCE_GROUP }}
          location: francecentral
          ingress: external
          targetPort: 8000
          disableTelemetry: true

      - name: Build and deploy domain-monitor Container App
        if: matrix.include_ca == true
        uses: azure/container-apps-deploy-action@v2
        with:
          imageToDeploy: fluorite.azurecr.io/domain-monitor:${{ env.VERSION }}
          containerAppName: ${{ env.DOMAIN_MONITOR_CONTAINER_APP_NAME }}
          containerAppEnvironment: ${{ env.DOMAIN_MONITOR_CONTAINER_APP_ENVIRONMENT }}
          resourceGroup: ${{ env.RESOURCE_GROUP }}
          location: francecentral
          ingress: external
          targetPort: 8000
          disableTelemetry: true

      - name: Setup attestation-transparency and domain-monitor services
        if: matrix.include_ca == true
        uses: azure/cli@v2
        with:
          azcliversion: latest
          inlineScript: |
            set -euo pipefail

            # Shared
            RESOURCE_GROUP="${{ env.RESOURCE_GROUP }}"
            ZONE_NAME="${{ env.ZONE_NAME }}"

            # Setup attestation-transparency
            CONTAINER_APP="${{ env.ATS_CONTAINER_APP_NAME }}"
            CONTAINER_APP_ENV="${{ env.ATS_CONTAINER_APP_ENVIRONMENT }}"
            A_RECORD_NAME="ats.${{ env.JOB_NAME }}"

            # Assign attestation-transparency-service-identity to Container App
            # This is needed because the container needs permission to write to Azure Blob Storage
            az containerapp identity assign \
              --name $CONTAINER_APP \
              --resource-group $RESOURCE_GROUP \
              --user-assigned attestation-transparency-service-identity

            # Set environment variables

            # Set environment variables
            az containerapp update \
              --name $CONTAINER_APP \
              --resource-group $RESOURCE_GROUP \
              --set-env-vars \
              PORT="8000" \
              ATTESTATION_BACKEND="${{ env.ATTESTATION_BACKEND }}" \
              PASSWORD="${{ env.ATS_PASSWORD }}" \
              OPERATOR_CERTIFICATE_B64="${{ env.OPERATOR_CERTIFICATE_B64 }}" \
              BUNDLE_HASH="${{ env.BUNDLE_HASH }}" \
              OS_MEASUREMENT="${{ env.OS_MEASUREMENT }}" \
              RESOURCE_GROUP_NAME="${{ env.RESOURCE_GROUP }}" \
              ATTESTATION_STORAGE_ACCOUNT_NAME="attestationproofs" \
              STORAGE_URL="${{ env.BLOB_STORAGE_URL }}" \
              AZURE_SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
              IDENTITY_RESOURCE_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/attestation-transparency-service-identity" \
              PLATFORM_MEASUREMENTS_PATH="${{ env.PLATFORM_MEASUREMENTS_PATH }}" 

            ./scripts/setup-containerapp.sh $RESOURCE_GROUP $CONTAINER_APP $CONTAINER_APP_ENV $ZONE_NAME $A_RECORD_NAME & 

            # Setup domain-monitor
            CONTAINER_APP="${{ env.DOMAIN_MONITOR_CONTAINER_APP_NAME }}"
            CONTAINER_APP_ENV="${{ env.DOMAIN_MONITOR_CONTAINER_APP_ENVIRONMENT }}"
            A_RECORD_NAME="domainmonitor.${{ env.JOB_NAME }}"

            # Set environment variables
            az containerapp update \
              --name $CONTAINER_APP \
              --resource-group $RESOURCE_GROUP \
              --set-env-vars \
              PORT="8000" \
              ATTESTATION_BACKEND="${{ env.ATTESTATION_BACKEND }}" \
              OPERATOR_CERTIFICATE_B64="${{ env.OPERATOR_CERTIFICATE_B64 }}" \
              BUNDLE_HASH="${{ env.BUNDLE_HASH }}" \
              OS_MEASUREMENT="${{ env.OS_MEASUREMENT }}" \
              STORAGE_URL="${{ env.BLOB_STORAGE_URL }}" \
              PLATFORM_MEASUREMENTS_PATH="${{ env.PLATFORM_MEASUREMENTS_PATH }}" \
              OS_DISK_URL="${{ env.OS_DISK_URL }}" \
              PROVISIONING_PACKAGE_URL="${{ env.PACKAGE_URL }}" 

            ./scripts/setup-containerapp.sh $RESOURCE_GROUP $CONTAINER_APP $CONTAINER_APP_ENV $ZONE_NAME $A_RECORD_NAME & 

            wait

      # It can happen that authentication expires at this point because the previous steps take around 10 minutes
      # So refresh the token by logging-in again
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Spawn VMs for test
        working-directory: operator/fluorite-azure-cli/
        run: |
          # Install the local version on purpose
          uv tool install .
          fluorite-azure \
            --location ${{ env.VM_LOCATION }} \
            --resource-group-name "EndToEndTest-${{ env.JOB_NAME }}" \
            --vm-type ${{ env.VM_TYPE }} \
            --num-control-plane-nodes 1 \
            --num-agent-nodes 1 \
            --operator-pem-cert-path ${{ env.OPERATOR_CERTIFICATE_PATH }} \
            --vm-security-type ${{ env.ATTESTATION_BACKEND }} \
            --community-gallery-image-id "${{ env.AZURE_IMAGE }}" \
            --output-path ${{ env.DIR }}/cluster.json

      - name: Create A record for master VM
        uses: azure/cli@v2
        with:
          azcliversion: latest
          inlineScript: |
            RESOURCE_GROUP="${{ env.RESOURCE_GROUP }}"            
            A_RECORD_NAME="${{ env.JOB_NAME }}"
            MASTER_IP=$(az vm list-ip-addresses -g "EndToEndTest-${{ env.JOB_NAME }}" -n master-vm --query "[].virtualMachine.network.publicIpAddresses[0].ipAddress" -o tsv)

            # Add the A record for the master vm
            # TTL set to 10 minutes
            az network dns record-set a add-record \
              --resource-group $RESOURCE_GROUP \
              --zone-name ${{ env.ZONE_NAME }} \
              --record-set-name $A_RECORD_NAME \
              --ipv4-address $MASTER_IP  \
              --ttl 600

            echo "MASTER_IP=$MASTER_IP" >> $GITHUB_ENV

      - name: Provision VMs
        run: |
          ${{ env.DIR }}/binaries/fluorite deploy \
            --zarf-package-path ${{ env.PACKAGE_PATH }} \
            --os-measurement ${{ env.OS_MEASUREMENT }} \
            --platform-measurements-path ${{ env.PLATFORM_MEASUREMENTS_PATH }} \
            --operator-cert-path ${{ env.OPERATOR_CERTIFICATE_PATH }} \
            --operator-private-key-path ${{ env.OPERATOR_PRIVATE_KEY_PATH }} \
            --cluster-file-path ${{ env.DIR }}/cluster.json \
            --deployment-config-path ${{ env.DEPLOYMENT_CONFIG_PATH }} \
            --attestation-backend ${{ env.ATTESTATION_BACKEND }}

      - name: Wait for DNS propagation
        run: |
          # Check every 30 seconds for 10 minutes
          MAX_RETRIES=20
          COUNT=0

          echo "Checking if ${{ env.HOSTNAME }} points to ${{ env.MASTER_IP }}..."

          while [ $COUNT -lt $MAX_RETRIES ]; do
              CURRENT_IP=$(dig +short A ${{ env.HOSTNAME }})

              if [ "$CURRENT_IP" == "${{ env.MASTER_IP }}" ]; then
                  exit 0
              fi

              echo "Retrying... (Attempt $((COUNT+1))/$MAX_RETRIES - Found: $CURRENT_IP)"
              sleep 30
              COUNT=$((COUNT+1))
          done

          exit 1

      - name: Run the client app
        run: |
          # Note: BLOB_STORAGE_URL will be empty when include_ca==false
          CA_FLAG=$([[ "${{ matrix.include_ca }}" == "true" ]] && echo "--blob-storage-url ${{ env.BLOB_STORAGE_URL }}" || echo "")

          ${{ env.DIR }}/binaries/client \
            --master-url "https://${{ env.HOSTNAME }}" \
            --operator-certificate-path ${{ env.OPERATOR_CERTIFICATE_PATH }} \
            --bundle-hash ${{ env.BUNDLE_HASH }} \
            --os-measurement ${{ env.OS_MEASUREMENT }} \
            --platform-measurements-path ${{ env.PLATFORM_MEASUREMENTS_PATH }}  \
            --attestation-backend ${{ env.ATTESTATION_BACKEND }} \
            $CA_FLAG

      - name: Delete resource group
        if: always()
        uses: azure/cli@v2
        with:
          azcliversion: latest
          inlineScript: |
            az group delete -n "EndToEndTest-${{ env.JOB_NAME }}" --force-deletion-types Microsoft.Compute/virtualMachines --yes
